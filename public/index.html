<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THREE JS - Lesson</title>
</head>
<body>

    <style>
        * {margin:0;padding:0;}

        body {overflow: hidden;}

        .container {width: 100%; height: 100vh;}
    .loading {
        position: fixed;
        z-index: 50;
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        background: #f1f1f1;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .loader {
        -webkit-perspective: 120px;
        -moz-perspective: 120px;
        -ms-perspective: 120px;
        perspective: 120px;
        width: 100px;
        height: 100px;
    }

    .loader::before {
        content: "";
        position: absolute;
        left: 25px;
        top: 25px;
        width: 50px;
        height: 50px;
        background-color: #ff0000;
        animation: flip 1s infinite;
    }

    @keyframes flip {
        0% {
            transform: rotate(0);
        }

        50% {
            transform: rotateY(180deg);
        }

        100% {
            transform: rotateY(180deg) rotateX(180deg);
        }
    }
    </style>

    <!-- The loading element overlays all else until the model is loaded, at which point we remove this element from the DOM -->
    <div class="loading" id="js-loader">
        <div class="loader"></div>
    </div>
    <!-- These toggle the the different parts of the chair that can be edited, note data-option is the key that links to the name of the part in the 3D file -->
    <!-- The canvas element is used to draw the 3D scene -->
    <canvas id="c"></canvas>
    <div class="controls">
        <!-- This tray will be filled with colors via JS, and the ability to slide this panel will be added in with a lightweight slider script (no dependency used for this) -->
        <div id="js-tray" class="tray">
            <div id="js-tray-slide" class="tray__slide"></div>
        </div>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.139.0/build/three.module.js",
                "OrbitControls": "https://unpkg.com/three@0.139.0/examples/jsm/controls/OrbitControls.js",
                "GLTFLoader": "https://unpkg.com/three@0.139.0/examples/jsm/loaders/GLTFLoader.js",
                "RectAreaLightHelper": "https://unpkg.com/three@0.139.0/examples/jsm/helpers/RectAreaLightHelper.js",
                "RectAreaLightUniformsLib": "https://unpkg.com/three@0.139.0/examples/jsm/lights/RectAreaLightUniformsLib.js"
            }
        }
    </script>
	<script type="module">

        import * as THREE from 'three';
        import { OrbitControls } from 'OrbitControls';
        import { GLTFLoader } from 'GLTFLoader';
        import { RectAreaLightHelper } from 'RectAreaLightHelper'
        import { RectAreaLightUniformsLib } from 'RectAreaLightUniformsLib';

		var modelName = location.search.split('model=')[1];
		
		const TRAY = document.getElementById('js-tray-slide');

		//структура для массива
		function matInfo(name, mat, texVars) {
			this.name = name;
			this.mat = mat;
			this.texVars=new Array();
			this.texVars.push(...texVars);
		}

		let matsWithTex = new Array(); // содержит name, mat, и массив текстур texVars
		let matsWithTexNames = new Array(); // содержит имена для поиска
		const mainScene = new THREE.Scene()

        const LOADER = document.getElementById('js-loader');
		var index = 1;

		
		//для определения существует ли файл
		const getFile = async(url) => {			
			let response = await (() => fetch(url))();
			return await response.status;
		}
		//возвращает текстуру
		const GiveMeTexture = async(textureArray, url) => {
			const loader = new THREE.TextureLoader();
			loader.load(
				// resource URL
				url,

				// onLoad callback
				function ( texture ) {
					texture.colorSpace = THREE.SRGBColorSpace;				
					texture.flipY = false;
					textureArray.push(texture);
				},

				// onProgress callback currently not supported
				undefined,

				// onError callback
				function ( err ) {					
				}
			)
		}
		//проверяет, есть ли в массиве элемент
		function contains(arr, elem) {
			var f = typeof elem == 'function' ? elem : ( i => i === elem );
			return arr.findIndex(f) != -1;
		}

        async function init() {
            let container = document.querySelector('.container');

            //сцена
            {
				mainScene.background = new THREE.Color("#E2DFE1");
				let plain; //пол
				{
					plain = new THREE.Mesh(
						new THREE.PlaneGeometry(1000, 1000),
						new THREE.MeshBasicMaterial({color: "#E2DFE1"})
					)
					plain.reciveShadow = true;
					plain.position.set(0, -1, 0)
					plain.rotateX(-Math.PI / 2);
					mainScene.add(plain)
            	}
				//собираем инфу о модели и загружаем на сцену
				const loader = new GLTFLoader();
        console.log('models/' + modelName + '/scene.gltf')
				await loader.load('models/' + modelName + '/scene.gltf', gltf => 
					{
						const model = gltf.scene;
						LOADER.remove();
						model.traverse( async child => {
							if(child.isMesh){
								if(!matsWithTexNames.includes(child.material.name)){
									matsWithTexNames.push(child.material.name);
									let find = true;
									let i = 1;
									let textureArray = new Array();
									//ищем все вариантики
									while(find){
										if(child.material.map != null){
											var status = await getFile('models/' + modelName + '/textures/' + child.material.name + '/' + child.material.name + '_baseColor' + i + '.jpeg')
											if (status == "200")
											{
												let tempTexture = await GiveMeTexture(textureArray,'models/' + modelName + '/textures/' + child.material.name + '/' + child.material.name + '_baseColor' +  i + '.jpeg');
												i= i + 1;
											} else {find= false;}
										} else {find= false;}
									}
									matsWithTex.push(new matInfo(child.material.name, child.material, textureArray));
								}
							}
						});
              console.log(matsWithTex);
              mainScene.add(model);
            }, 
						function (error) {
						}
				)

				//освещение
				{
					{
						const light = new THREE.DirectionalLight(0xffffff, 1)
						light.position.set(-2, 0, 10)
						light.lookAt(0, -1, 0)
						mainScene.add(light)
					}

					{
						const light = new THREE.DirectionalLight(0xffffff, 1)
						light.position.set(2, 0, 5)
						light.lookAt(0, 1, 0)
						mainScene.add(light)
					}

					RectAreaLightUniformsLib.init();
					{
						const rectLight = new THREE.RectAreaLight(0xffffff, 1, 100, 100);
						rectLight.position.set(-10,0,0)
						rectLight.rotation.y = Math.PI + Math.PI/4;
						mainScene.add(rectLight)
					}

					{
						const rectLight = new THREE.RectAreaLight(0xffffff, 1, 100, 100);
						rectLight.position.set(10,0,0)
						rectLight.rotation.y = Math.PI - Math.PI/4;
						mainScene.add(rectLight)
					}
					
				}
			}

            //камера
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            camera.position.set(0, 0.5, 1)

            //рендер

			const canvas = document.querySelector('#c');
            const renderer = new THREE.WebGLRenderer({canvas, antialias: true})
            renderer.setSize(window.innerWidth, window.innerHeight)
			document.body.appendChild(renderer.domElement);
            

            
            
			//OrbitControls
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.autoRotate = true;
            controls.autoRotateSpeed = 5;
            controls.enableDamping = true;

			function resizeRendererToDisplaySize(renderer) {
				const canvas = renderer.domElement;
				var width = window.innerWidth;
				var height = window.innerHeight;
				var canvasPixelWidth = canvas.width / window.devicePixelRatio;
				var canvasPixelHeight = canvas.height / window.devicePixelRatio;
				const needResize = canvasPixelWidth !== width || canvasPixelHeight !== height;
				if (needResize) {
					renderer.setSize(width, height, false);
				}
				return needResize;
			}

            // Animate
            function animate() {				
                renderer.render(mainScene, camera);
                requestAnimationFrame(animate);

				if(resizeRendererToDisplaySize(renderer)){
					const canvas = renderer.domElement;
    				camera.aspect = canvas.clientWidth / canvas.clientHeight;
    				camera.updateProjectionMatrix();
				}
                controls.update();
            }
            animate()

			


        }

		

        init()
    </script>
</body>
</html>